### require JS 源码解析

#### 前言
这段时间看了requireJS的源码，了解了整体的架构以及大致的实现流程，整理笔记如下。

#### 学习准备
先了解大致思想，以免迷迷糊糊的往下看。

模块化解决方案，是想让我们能够把代码分割成多个模块，实现代码复用，逻辑分割，更加利于我们团队开发和项目维护，这是模块化开发的实际意义，但是因为模块化有不同的解决方案涉及不同的规范（COMMONJS、AMD、CMD等）这里不赘述各规范之间的区别。

因为浏览器端的文件加载是异步的，不像后端node，直接读取本地文件，所以需要一个异步加载的方案，也就有了AMD规范的出现，而AMD规范的实现的例子就是requireJS，当然开发阶段是分多个文件模块的，上线还要进行打包压缩，借住r.js和其他压缩工具，不赘述。

要求文件通过define API的形式来书写，意味着每一次加载进来一个文件，只是做了一个模块的注册工作，模块的真正的代码部分还未执行，而所谓真正的本模块的代码，就是回调函数内的代码，需要等待依赖加载执行完毕后，才会触发回调。

简言之，define做了模块注册工作，回调是本模块主业务逻辑代码，等待被执行。

其次，要讲到两个关键问题，一个是回调的触发时机，一个是本模块的名称和依赖相对应的问题。

第一个问题：回调的触发时机

什么时候执行本模块的回调函数？刚才说到会先去加载依赖，在触发加载依赖之前，会对子依赖先行封装，绑定define事件回调，（即子依赖加载执行后会触发该模块的define事件），define事件的回调里，就包括对父依赖的状态更新和check检查，（更新依赖数-1，check检查依赖是否加载完毕）
举个例子，a文件依赖b、c文件，b加载完后触发define事件，a依赖数-1，检查剩余依赖数为1，意味着还差一个依赖未加载执行，等到c文件加载执行完后，c文件触发define事件，a依赖数-1，检查剩余依赖数为0，a文件可执行，触发a模块的回调函数，并且将对应模块通过传入参数的方式注入函数内以供调用。

第二个问题：a文件内执行的define API，a文件是不知道自己是a文件的，那么怎么把define中传入的依赖数组和回调函数 与 我们的模块名对应起来呢？

每次append新的script节点来加载新的文件的时候，会绑定onload事件，script执行结束后，会触发onload事件回调，也就是define注册后将信息存入了depsQueue队列中，接下来onload回调中只需要取队列首个对象，通过event.target的方式获取script节点上的模块名，就可以实现模块名与依赖的对应关系。

为什么可以这么做呢？因为即使a依赖b、c文件，b、c文件同时加载，但是加载时间和顺序不一致，c可能先加载完，但是代码的执行顺序 还是先b后c，所以当前队列首个对象 一定是刚注册完的模块。

#### 具体流程 API 详解

- 1、调用require方法，先进行参数的判断。之后调用context下的require方法 
- 2、context的require方法来源于makeRequire里封装的localRequire方法，里面进行了deps参数的判断，如果是正常的依赖加载，通过调用nextTick，异步操作，获取模块的map，之后封装成module对象，（module对象有事件对象、依赖项、依赖计数还有原型链上封装的一些方法），调用module的init操作初始化模块。 
- 3、init方法做了错误监听，还有数据初始化，之后调用模块的enable方法。 
- 4、enable方法中缓存模块对象进enabledRegistry 中，之后遍历依赖项，遍历过程中，依赖计数depCount++，把依赖项封装成对应的模块的map，之后对子模块设定define事件监听，回调函数是调用父模块的check方法，检查是否可执行。方法最后执行了一次check方法。 
- 5、如果一个模块进入check方法调用，如果已被定义且依赖计数小于1，即加载完依赖的情况下，执行该模块的回调函数，同时清除对应id的registry，触发模块上的define事件。（即变相通知了依赖本模块的父模块）


### 调试和查看方式： 
new Error 查看函数调用栈 
断点调试 
consolelog